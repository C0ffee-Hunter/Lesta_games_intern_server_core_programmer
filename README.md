# Lesta_games_intern_server_core_programmer

## Задание 1:
Функция:
def isEven_2(value):
    return value & 1 == 0

  На языке питон была написана функция для определения четности целого числа с помощью проверки последнего разряда в двоичной системе счисления. Результаты показали, что вариант с проверкой последенего разряда зачастую выполняется быстрее, чем вариант с нахождением остатка десятичного числа. Исключением является  работа с большими числами, где проверка разряда в двоичной системе показывает результаты хуже
  

 
## Задание 2:
  Напишем на Python 2 класса, один из которых будет основан на списке, а другой н коллекции deque 
  С классом на основе списка можно ознакомиться [здесь](https://github.com/C0ffee-Hunter/Lesta_games_intern_server_core_programmer/blob/master/Python/task_2_Circular.py)
  ### Плюсы и минусы:
  Плюсы:
  - Постоянное время доступа O(1) для операций enqueue и dequeue.
  Минусы:
  - Использует фиксированный размер массива, что может привести к неэффективному использованию памяти.
  - Неэффективен при работе с динамически изменяющимися буферами, так как требуется создание нового массива и копирование данных при изменении размера.
  
  С классом на основе колекции deque можно ознакомиться [здесь](https://github.com/C0ffee-Hunter/Lesta_games_intern_server_core_programmer/blob/master/Python/task_2_deque.py)

  ### Пдюсы и минусы:
  Плюсы:
  - Использует встроенную структуру deque, которая оптимизирована для добавления и удаления элементов с обеих сторон.
  Минусы:
  - deque не поддерживает фиксированный размер, вместо этого элементы автоматически удаляются с противоположного конца при добавлении новых, когда буфер полон, что может не подходить для всех приложений.
  - Может использовать больше памяти, чем нужно, из-за особенностей реализации deque.
  

##Задание 3:
	На мой взгляд, найти единственный быстрый алгоритм сортировки весьма сложно. Первое, что приходит на ум – это алгоритм «Быстрой сортировки», но его проблема в том, что в худшем случае (уже отсортированный массив или все числа одинаковы) он имеет временную сложность O(n^2), что весьма не самый хороший показатель. Можно посмотреть на остальные алгоритмы. «Сортировка слиянием» весьма быстрая (О(n log n)), но требует дополнительной памяти O(n). Неплохо себя показывает Timsort, которая является гибридом «Сортировки слиянием» и « Сортировкой вставками», что дает в худшем случае дает ему сложность в O(n log n), а это весьма быстро.
Реализация алгоритма Timsort на python весьма проста благодаря встроенной функции:

def timsort(arr): 
	arr.sort() 
	return arr
